// fix_all.mjs
// Run: node fix_all.mjs
// Node 25+, project using ESM ("type": "module")

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const ROOT = __dirname;
const INDEX_PATH = path.join(ROOT, 'index.js');
const COMMANDS_DIR = path.join(ROOT, 'commands');

function backup(filePath) {
  if (!fs.existsSync(filePath)) return;
  const bak = filePath + '.bak';
  if (!fs.existsSync(bak)) {
    fs.copyFileSync(filePath, bak);
    console.log('Backup created:', bak);
  } else {
    const bak2 = `${filePath}.bak.${Date.now()}`;
    fs.copyFileSync(filePath, bak2);
    console.log('Backup created:', bak2);
  }
}

function safeWrite(filePath, content) {
  fs.writeFileSync(filePath, content, 'utf8');
  console.log('Wrote:', filePath);
}

/* ---------- Part 1: Replace index.js with an ESM-ready template (backup kept) ---------- */
if (fs.existsSync(INDEX_PATH)) {
  backup(INDEX_PATH);

  const newIndex = `// index.js - ESM-ready Discord.js helper (Node 25+)
// Generated by fix_all.mjs
import 'dotenv/config';
import fs from 'fs';
import path from 'path';
import express from 'express';
import { fileURLToPath } from 'url';
import { Client, GatewayIntentBits, Collection } from 'discord.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const TOKEN = process.env.DISCORD_TOKEN;
const OWNER_ID = process.env.OWNER_ID || null;
const PREFIX = process.env.PREFIX || '!';
const PORT = process.env.PORT || 3000;
const PRESENCE = process.env.PRESENCE || 'Helping servers build';

if (!TOKEN) {
  console.error('FATAL: DISCORD_TOKEN not found in environment. Aborting.');
  process.exit(1);
}

const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMembers,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent,
  ],
});

// Collections
client.commands = new Collection();
client.cooldowns = new Collection();

// Dynamic command loader (ESM safe)
const commandsPath = path.join(__dirname, 'commands');
if (fs.existsSync(commandsPath)) {
  const files = fs.readdirSync(commandsPath).filter(f => f.endsWith('.js'));
  for (const file of files) {
    try {
      const filePath = path.join(commandsPath, file);
      const mod = await import('file://' + filePath);
      const cmd = mod.default ?? mod;
      if (!cmd || !cmd.name || typeof cmd.execute !== 'function') {
        console.warn('Skipping invalid command file:', file);
        continue;
      }
      client.commands.set(cmd.name, cmd);
      if (Array.isArray(cmd.aliases)) for (const a of cmd.aliases) client.commands.set(a, cmd);
      console.log(\`Loaded command: \${cmd.name} (\${file})\`);
    } catch (err) {
      console.error('Failed loading command', file + ':', err);
    }
  }
} else {
  console.warn('No commands folder found at ./commands');
}

// clientReady / ready compatibility
client.once('clientReady', () => {
  console.log(\`\${client.user.tag} is online!\`);
  try { client.user.setActivity(PRESENCE); } catch (e) {}
});
client.once('ready', () => {
  // fallback for v14
  console.log('ready event fired (fallback)');
});

// Message handler
client.on('messageCreate', async (message) => {
  try {
    if (!message.guild || message.author.bot) return;
    if (!message.content.startsWith(PREFIX)) return;

    const args = message.content.slice(PREFIX.length).trim().split(/\\s+/);
    const invoked = args.shift().toLowerCase();
    const command = client.commands.get(invoked);
    if (!command) return;

    if (command.ownerOnly && String(message.author.id) !== String(OWNER_ID)) {
      return message.reply('You are not allowed to use this command.');
    }

    // Cooldowns
    const now = Date.now();
    const timestamps = client.cooldowns.get(command.name) || new Collection();
    const cooldownAmount = (command.cooldown || 3) * 1000;

    if (timestamps.has(message.author.id)) {
      const expiration = timestamps.get(message.author.id) + cooldownAmount;
      if (now < expiration) {
        const timeLeft = Math.ceil((expiration - now) / 1000);
        return message.reply('Please wait ' + timeLeft + 's before using \"' + PREFIX + command.name + '\" again.');
      }
    }

    timestamps.set(message.author.id, now);
    client.cooldowns.set(command.name, timestamps);
    setTimeout(() => timestamps.delete(message.author.id), cooldownAmount);

    await command.execute(client, message, args);
  } catch (err) {
    console.error('Error handling messageCreate:', err);
    try { await message.reply('Something went wrong while processing that command.'); } catch {}
  }
});

// Guild events
client.on('guildMemberAdd', (member) => {
  try { member.guild.systemChannel?.send('Welcome to ' + member.guild.name + ', ' + member.user + '! ðŸŽ‰'); } catch (e) {}
});
client.on('guildMemberRemove', (member) => {
  try { member.guild.systemChannel?.send(member.user.tag + ' has left the server.'); } catch (e) {}
});

// Global errors
process.on('unhandledRejection', (reason) => console.error('Unhandled Rejection:', reason));
process.on('uncaughtException', (err) => console.error('Uncaught Exception:', err));

// Heartbeat
const app = express();
app.get('/', (req, res) => res.send('OK'));
app.get('/ping', (req, res) => res.status(200).send('Pong'));
app.listen(PORT, () => console.log('Heartbeat server listening on port ' + PORT));

// Graceful shutdown
async function shutdown(sig) {
  console.log('Received ' + sig + ', shutting down...');
  try { await client.destroy(); } catch (err) { console.warn('Error destroying client:', err); }
  process.exit(0);
}
process.on('SIGINT', () => shutdown('SIGINT'));
process.on('SIGTERM', () => shutdown('SIGTERM'));

// Login
client.login(TOKEN).catch(err => {
  console.error('Failed to login:', err);
  process.exit(1);
});
`;

  safeWrite(INDEX_PATH, newIndex);
  console.log('index.js replaced (original backed up).');
} else {
  console.warn('index.js not found â€” skipping index replacement.');
}

/* ---------- Part 2: Fix command files (add JSON assert + clean stray lines) ---------- */
if (fs.existsSync(COMMANDS_DIR)) {
  const files = fs.readdirSync(COMMANDS_DIR).filter(f => f.endsWith('.js'));
  // build a RegExp safely via constructor (no literal slashes that confuse parser)
  const jsonImportPattern = new RegExp(
    'import\\\\s+(\\\\w+)\\\\s+from\\\\s+([\'"])(\\\\.\\\\.\\\\/package\\\\.json|\\\\.\\\\/package\\\\.json)\\\\2\\\\s*;?',
    'g'
  );

  for (const file of files) {
    const fp = path.join(COMMANDS_DIR, file);
    backup(fp);
    let content = fs.readFileSync(fp, 'utf8');

    // Replace import pkg from '../package.json' => import pkg from '../package.json' assert { type: 'json' };
    content = content.replace(jsonImportPattern, (match, varName, quote, pkgPath) => {
      // pkgPath is like ../package.json or ./package.json
      return `import ${varName} from '${pkgPath}' assert { type: 'json' };`;
    });

    // Remove obvious stray pasted log lines (very conservative)
    const lines = content.split(/\r?\n/);
    const cleaned = lines.filter(l => {
      if (/^\s*re\/\//i.test(l)) return false;
      if (/^\s*SyntaxError:/.test(l)) return false;
      if (/Unexpected identifier/.test(l)) return false;
      if (/index\.js - Discord\.js/i.test(l)) return false;
      return true;
    });

    const newContent = cleaned.join('\n');
    if (newContent !== content) {
      fs.writeFileSync(fp, newContent, 'utf8');
      console.log('Fixed command file:', file);
    } else {
      console.log('No change for:', file);
    }
  }
} else {
  console.warn('No commands directory at ./commands â€” skipping command fixes.');
}

console.log('\nFixer finished. Start the bot with: node index.js');
